1，线程通信 与 线程同步   （区别进程间通信与同步）
    线程之间的通信 与 同步是并发编程的两个核心问题。在OS概念中，通信是指线程之间以何种机制来进行信息交互，通常有线程间通信有两种机制：共享内存和消息传递。前者通过写-读内存中的公共状态进行隐式通信，后者没有公共状态，必须通过发送消息来显式通信；同步指程序中用于控制不同线程间操作顺序的机制（和宏观的数据同步不是一个概念），同步是一种复杂的互斥，在共享内存的并发模型里，同步是显式的，程序员必须指定某个方法或者代码块需要在线程间互斥。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，所以同步是隐式进行的。
    Java的线程间通信采用的是共享内存模型，因此Java线程间通信总是隐式进行的，整个通信过程对程序员是透明的。

2，Java内存模型
    Java线程间通信由Java内存模型控制，Java内存模型规定了主内存中变量的操作规则，主内存中存储了所有的共享变量，包括实例字段、静态变量和数组。另外，Java中每个线程都拥有一个工作内存（它涵盖了缓存，写缓冲区，寄存器等），用于存储主内存中共享变量副本已经线程的私有变量。

3，volatile
    volatile被称为轻量级锁，对被volatile修饰的变量进行写操作在处理器上会发生两件事：
（1）将当前处理器缓存行的数据写回到系统内存（工作内存->主内存）
（2）这个写回操作会使在其他处理器里缓存了该内存地址的数据无效
     为了提高处理器的执行速度，工作内存一般不会与主内存直接通信，而是拷贝主内存中的共享变量的副本到工作内存，但完全不知道什么时候会写回主内存。如果加了volatile修饰，JVM就会发送一条写回主内存的指令。另外，为了保证各处理器缓存数据的一致性，指定了缓存一致性协议，每个处理器通过嗅探总线上传播的数据来检查自己的缓存是不是过期。

* 3.1 合理使用的前提下，为什么volatile的使用和执行成本比synchronized低？
    因为volatile不会引起线程上下文的切换和调度。

* 3.2 volatile并不能解决i++线程不安全的问题，它解决的是共享变量内存可见性问题。

4，偏向锁
    偏向锁并不是锁的一种类别，而是锁的一种状态，表示锁的竞争程度，JVM1.6定义了锁的4种状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。当一个线程访问同步代码块并获取锁时，会在对象头中记录锁偏向的线程id，同一线程再次进入时不需要进行CAS操作来加锁和解锁。属于锁优化的一种手段，JVM对该状态默认开启，可关闭。
